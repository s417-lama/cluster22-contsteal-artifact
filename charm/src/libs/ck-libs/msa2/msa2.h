// A second shot at multiphase shared arrays

#include <utility>
#include <vector>
#include <charm++.h>
#include <boost/multi_array.hpp>

namespace MSA
{
    typedef unsigned short Dimension;
    typedef CmiUInt8 cache_id;
    using std::pair;
    using std::vector;

    template <class T>
	class cache_line
    {
        
    };

    template <class T>
        class modifiable_cache_line
    {
        // Write map, to indicate what needs to be sent back
        
    };

    template <class T>
        class write_cache_line
    {

    };

    template <class T>
        class accum_cache_line
    {

    };


    // Create an MSA of the given size and arrangement
    template <class T, Dimension D>
        cache_id make_msa(const ExtentList& array_size,
                          const ExtentList& section_size,
                          const ExtentList& line_size,
                          const storage_order_type& storage_layout,
                          const T& default_value)
    {
        // Create array of elements
        // Register array with cache managment group
        // Return id generated by cache manager
    }

    template <class T, Dimension D>
        class handle
    {
        // Which sections hold which elements?
        section_map &sections;
        // Which cache line and entry holds a given element?
        element_layout &layout;
        // Which cache lines did we pull in?
        vector<cache_line<T>*> lines;
        // Has this handle been invalidated?
        bool valid;
    };

    template <class T, Dimension D>
        class read  : public handle<T, D>
    {
    public:
        // Get operations
        
    private:
        // No unique data
    };

    template <class T, Dimension D>
        class write : public handle<T, D>
    {
    public:
        // Assignment operations

    private:
        // Write map
    };

    template <class T, Dimension D>
        class accum : public handle<T, D>
    {
    public: 
        // Accumulation operations

    private:
        // Write map
        // Accumulation operator
    };

    template <class T, Dimension D>
        class owner : public handle<T, D>
    {
    public:
        // Iteration over local pages

    private:
        // ??? Distribution of local pages over locally operating objects/threads?

    };

    
}

// emacs mode line: -*- mode: c++; c-set-style: stroustrup; indent-tabs-mode: nil; -*-
